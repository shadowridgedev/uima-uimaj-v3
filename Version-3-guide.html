	<!--
    ***************************************************************
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    * 
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    ***************************************************************
   -->
<html>
<head>
  <link rel="stylesheet" type="text/css" href="javascripts/prism.css">
  <script src="javascripts/prism.js"></script>
  <title>Apache UIMA v3 Guide</title>
</head>
<body>
<h1>Apache UIMA&trade; Version 3 Guide</h1>
<h2>Contents</h2>
<p><a href="#overview">Overview</a><br /> <a href="#backward-compatibility">Backward Compatibility<br /></a> <a href="#Java8enablement">Java 8 enablement<br /><br /></a></p>
<h2><a id="overview"></a>Overview of UIMA Version 3</h2>
<p>Version 3 (V3) of Apache UIMA&trade; is a mostly backwards compatible evolution of the Java framework. Following trends in hardware over the last 10-15 years, it adjusts the balance between space and time trade offs in favor of better performance at some cost in space. It changes the model of how Feature Structures (FSs) are stored to one where each FS is an instance of a Java class (possibly a user-defined JCas class, similar to Version 2 (V2) ), which contains all of the data.</p>
<p>The benefits of V3 include:</p>
<ul>
<li>no longer referenced FSs can be garbage collected</li>
<li>performance improvements from many things.
<ul>
<li>indexes improved</li>
<li>better locality-of-reference: gives better performance on modern processor architecture memory hierarchies</li>
</ul>
</li>
</ul>
<p>Java 8 or later is a prerequisite.</p>
<h3>JCas classes need to be regenerated or migrated</h3>
<p>The internal implementation of a FS is changed; this requires that any JCas classes be regenerated to conform to the new implementation. To aid in the migration, the MigrateJCas tool can be used. It is given some file system roots, and it proceeds to scan the file directories at those roots, looking for JCas source or class (compiled Java) files, including inside JARs and PEARs. When it finds these, it attempts to convert these from the V2 style to the V3 style, while preserving any customization and additions the user may have done to the JCas class. It prepares a report that allows you to quickly review the conversion and see if there's anything it couldn't do, which may need some "manual" conversion.</p>
<h2><a id="backward-compatibility"></a>Backwards Compatibility</h2>
<p>V3 is designed to allow graceful migration and some level of interoperability. &nbsp;For example, in a UIMA-AS environment, services running on V2 ought to work with clients running V3, and vice versa.</p>
<p>Furthermore, serialized CASs saved with V2 should be readable with V3 and vice versa, although the exact serialized data may be somewhat different. An example of the difference is that in V3, many of the serializations that used to serialize everything (e.g. Binary), will now only serialize the "reachable" FSs (because garbage collection may have reclaimed unreachable FSs). &nbsp;</p>
<p>Existing pipelines (after converting any user-supplied JCas classes) should run and produce the same output.</p>
<h2><a id="Java8enablement"></a>Java 8 enablement</h2>
<p>Accessing FSs via indexes is augmented with Java 8 streams. &nbsp;This means you can create a stream from an index and then use all the stream functionality to process the items in that stream. &nbsp;Used properly, the iterations are done lazily and more efficiently.</p>
<p>Be careful if using streams for parallel processing; there are many articles on the internet why this might be a bad idea.</p>
<p>Here's an example; note that some of the operators are not standard stream operators but will work with Annotation indexes (e.g. <code>reverse(), boundedBy()</code>, etc.):</p>
<pre class="language-java"><code>int filteredTextSum = index.stream()  //create a stream from an index
       .reverse()    
       .boundedBy(boundingAnnotation) // like subiterator
       .boundsRespectTypePriorities(true) // default is false
       .strict(true)  // default is false; same as nonOverlappingFSs(true)
       .mapToInt(f -&gt; f.getEnd() - f.getBegin()) // get the length of the covered text
       .sum(); // add all of these</code></pre>
<p>Streams from FSIndexes are built upon SplitIterator. &nbsp;This is a lower level Java 8 class; you can use it directly in place of iterators to get a somewhat more efficient iteration, 
without doing the "splitting" part or making use of the Stream functionality.</p></body>
</html>