<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd"[
<!ENTITY imgroot "images/version_3_users_guide/uv3.logging/">
<!ENTITY tp "uv3.migration.aids.">
<!ENTITY % uimaents SYSTEM "../../target/docbook-shared/entities.ent" >  
%uimaents;
]>
<!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->
<chapter id="uv3.logging">
  <title>Logging</title>
    
    <para>V3 retains the existing V2 logging facade, for backwards compatibility.
    It has been augmented by the methods available in the SLF4j <code>Logger</code> API,
    plus the Java 8 enabled APIs from the Log4j implementation that support the 
    <code>Supplier</code> Functional Interface.
    </para>
    
    <para>The implementation of this facade in V2 was the built-in-to-Java logging framework.
    For V3, this is changed to be the SLF4j facade.  This is an open source, standard facade
    which allows deferring until deployment time, the specific logging back end to use.
    </para>
    
    <para>If, at initialization time, SLF4J gets configuredto use a back end which is either the 
    built-in Java logger, or Log4j-2, then the UIMA logger implementation is switched to
    UIMA's implementation of those APIs (bypassing SLF4j, for efficiency).</para>

    <!--             
    <para>The v2 loggers support internationalization using resource bundles.  The logger
      gets the classpath via a handle to a ResourceManager, and uses that Resource Manager's Extension Classpath
      when looking up resource bundles.
    </para>
    
    <para>V2 loggers have logging methods <code>logrb</code> which take bundle keys and substitutable parameters.
      To do the equivalent using SLF4j logging, 
      a new method on the UIMA logger, <code>rb(String bundleName, String bundleKey, Object ... params)</code>
      will do the conversion to an internationalized string which can then be passed to 
      SLF4j.  This should be done using a Java 8 lambda <code>Supplier&lt;String&gt;</code>, 
      to avoid computing the value if logging is not enabled. 
    </para>
     -->
    
    <para> 
      The SLF4j and other documentation (e.g.,  
      <ulink url="https://logging.apache.org/log4j/2.x/log4j-slf4j-impl/index.html"/> for log4j-2) describe 
      how to connect various logging back ends to SLF4j, by 
      putting logging back-end implementations into the classpath at run time.  For example, 
      to use the back end logger built into Java,  you would
      include the <code>slf4j-jdk14</code> Jar.  This Jar is included in the UIMA binary distribution, so that
      out-of-the-box, logging is available and configured the same as it was for V2.
    </para>
    
    <para>The Eclipse UIMA Runtime plugin bundle excludes the slf4j api Jar and back ends, but will 
      "hook up" the needed implementations from other bundles.   
    </para> 
  
  <section id="uv3.logging.new_recorded_context_data">
    <title>Context Data</title>
      
    <note><para><emphasis role="bold">Not (yet) implemented; for planning purposes only.</emphasis></para></note>
    
    <para>
      Context data is kept in SLF4j MDC and/or NDC maps; there is a separate map per thread.  
      Some of this information is always updated, other is only recorded if the
      logger for the class has a level set to Tracing.  
      The following table lists the keys and the values recorded in the
      contexts; these can be retrieved by the logging layouts and included in log messages.      
    </para>
    
    <para>Because the keys for context data are global, the ones UIMA uses internally are prefixed with "uima_".</para>   
    
    <informaltable frame="all" rowsep="1" colsep="1">
     <tgroup cols="2">
       <colspec colnum="1" colname="key" colwidth="1*"/>
       <colspec colnum="2" colname="description" colwidth="3*"/>
       
       <spanspec spanname="fullwidth" namest="key" nameend="description" align="center"/>
        
       <tbody>
         <row>
           <entry><emphasis role="bold">Key Name</emphasis></entry>
           <entry><emphasis role="bold">Description</emphasis></entry>
         </row>

         <!-- ******************************************************************************* -->
         <row>
           <entry><para>uima_annotator</para></entry>         
           <entry><para>the name of the annotator.</para></entry>
         </row>
         
         <row>
           <entry><para>uima_root_context</para></entry>
           <entry><para>The root context corresponds to the pipeline being run.  This could be be nested.</para></entry>
         </row>

         <!-- <row>
           <entry><para>op_state</para></entry>
           <entry><para>An NDC, the operational state.  Could be in_annotator, in_flowController, in_serializer, etc.</para></entry>
         </row>   -->                
       </tbody>
     </tgroup>
   </informaltable>
    
  </section>

  <section id="uv3.logging.markers">
    <title>Markers used in UIMA Java core logging</title>
    
    <note><para><emphasis role="bold">Not (yet) implemented; for planning purposes only.</emphasis></para></note>
      
    <para>
      Markers are used to group log calls associated with specific kinds of things together,
      so they can be enabled/disabled as a group.  The Marker can also be included in a trace record.
      The following table lists the keys and a description of which logging they are associated with.
    </para>

    <informaltable frame="all" rowsep="1" colsep="1">
     <tgroup cols="2">
       <colspec colnum="1" colname="key" colwidth="20*"/>
       <colspec colnum="2" colname="description" colwidth="30*"/>
       
       <spanspec spanname="fullwidth" namest="key" nameend="description" align="center"/>
        
       <tbody>
         <row>
           <entry><emphasis role="bold">Marker Name</emphasis></entry>
           <entry><emphasis role="bold">Description of logging</emphasis></entry>
         </row>

         <row>
           <entry spanname="fullwidth"><emphasis role="bold">Markers used to classify CONFIG and FINE/FINER/FINEST </emphasis></entry>
         </row>
         <row>
           <entry><para>uima.config</para></entry>
           <entry><para>configuration log record</para></entry>
         </row>
         <row>
           <entry><para>uima.fine</para></entry>
           <entry><para>sub category of trace, corresponds to FINE</para></entry>
         </row>
         <row>
           <entry><para>uima.finer</para></entry>
           <entry><para>sub category of trace, corresponds to FINER</para></entry>
         </row>
         <row>
           <entry><para>uima.finest</para></entry>
           <entry><para>sub category of trace, corresponds to FINEST</para></entry>
         </row>
         
         <!-- ******************************************************************************* -->
         <row>
           <entry spanname="fullwidth"><emphasis role="bold">Markers used to classify some tracing logging</emphasis></entry>
         </row>
         <row>
           <entry><para>uima_annotator</para></entry>
           <entry><para>for tracing when annotators are entered, exited</para></entry>
         </row>

         <row>
           <entry><para>uima_flow_controller</para></entry>
           <entry><para>for tracing when flow controllers are computing</para></entry>
         </row>

         <row>
           <entry><para>uima_feature_structure</para></entry>
           <entry><para>for tracing Feature Structure Creation and updating</para></entry>
         </row>

         <row>
           <entry><para>uima_index</para></entry>
           <entry><para>for tracing when indexes are added to or removed from</para></entry>
         </row>
          
         <row>
           <entry><para>uima_index_copy_on_write</para></entry>         
           <entry><para>for tracing when an index part is copied, due to it being updated while an iterator might be iterating.</para></entry>
         </row>

         <row>
           <entry><para>uima_index_auto_rmv_add</para></entry>         
           <entry><para>for tracing when index corruption avoidance done</para></entry>
         </row>
            
         <row>
           <entry><para>uima_serialization_deserialization</para></entry>
           <entry><para>for tracing when serialization or deserialization is done</para></entry>
         </row>
                  
       </tbody>
     </tgroup>
   </informaltable>
        
  </section>
  
  <section id="uv3.logging.defaults_configuration">
    <title>Defaults and Configuration</title>
    
    <para>By default, UIMA is configured so that the UIMA logger is hooked up to the SLF4j facade, which
      may or may not have a logging back-end.  If it doesn't, then any use of the UIMA logger will produce 
      one warning message stating that SLF4j has no back-end logger configured, and so no logging will be done. 
    </para>
        
    <para>When UIMA is run as an embedded library in other applications, slf4j will use those other application's
      logging frameworks.</para>
      
    <para>Each logging back-end has its own way of being configured; 
      please consult the proper back-end documentation for details.</para>
    
    <para>For backwards compatibility, the binary distribution of UIMA includes the slf4j back-end 
      which hooks to the standard built-in Java logging framework, so out-of-the-box, UIMA should
      be configured and log by default as V2 did.</para>  
      
    <section id="uv3.logging.throttling_annotator_logging">
      <title>Throttling logging from Annotators</title>
      
       <para>Sometimes, in production, you may find annotators are logging excessively, and you wish to throttle 
          this. But you may not have access to logging settings to control this,
          perhaps because UIMA is running as a library component within another framework. 
          For this special case,
          you can limit logging done by Annotators by passing an additional parameter to the UIMA Framework's 
          produceAnalysisEngine API, using the key name 
          <code>AnalysisEngine.PARAM_THROTTLE_EXCESSIVE_ANNOTATOR_LOGGING</code>
          and setting the value to an Integer object equal to the the limit.  Using 0 will suppress all logging.
          Any positive number allows that many log records to be logged, per level.  A limit of 10 would allow 
          10 Errors, 10 Warnings, etc.  The limit is enforced separately, per logger instance.</para>
          
          <note><para>This only works if the logger used by Annotators is obtained from the 
          Annotator base implementation class via the <code>getLogger()</code> method.</para></note>
          
    </section>  
  </section>  
</chapter>