<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd"[
<!ENTITY imgroot "images/references/ref.json/">
<!ENTITY tp "ugr.ref.json.">
<!ENTITY % uimaents SYSTEM "../../target/docbook-shared/entities.ent" >  
%uimaents;
]>
<!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->
<chapter id="ugr.ref.json">
  <title>Serializing CASs and TypeSystems as JSON objects</title>

  <section id="ugr.ref.json.overview">
    <title>JSON serialization support overview</title>
     
    <para>Applications are moving to the "cloud", and new applications are being rapidly developed that are hooking
    things up using various mashup techniques.  New standards and conventions are emerging to support this kind
    of application development, such as REST services.  
    JSON is now a popular way for services to communicate; 
    its popularity is rising while XML is falling.</para>
    
    <para>Starting with version 2.6.1, JSON style serialization for CASs and TypeSystems is supported.
    The exact format is configurable in several aspects.  The support is built on top of Jackson JSON generation library.
    Serialization is supported for CASs and also for Type System descriptions.   
    </para>
    
    
  
  <section id="ug.ref.json.cas">
    <title>JSON CAS Serialization</title>
    
    <para>CASs primarily consist of collections of Feature Structures (FSs).  To support the kinds of things
    users do with FSs, the serialized form may need to include additional information enabling:</para>
    
    <itemizedlist>
      <listitem>
        <para>having a way to identify which fields in a FS should be treated as references to other FSs</para>
      </listitem>
      <listitem>
        <para>something like XML namespaces to allow the use of short names in the serialization but handle name
        collisions</para>
      </listitem>
      <listitem>
        <para>enough of the UIMA type hierarchy to allow the common operation of iterating over a type together 
        with all of its subtypes</para>
      </listitem>
    </itemizedlist>
    
    <para>Simple JSON serialization does not have a convention for supporting these, but many extensions do.
    We follow some of the concepts in the JSON-LD (linked data) standard, in providing (optional) 
    additional information for these three things: name-spaces, for identifying supertype chains of UIMA types, 
    and for specifying 
    which features ought to be considered to be references to other FeatureStructure instances (even though they
    are encoded as JSON numbers).</para>
    
    <para>CAS JSON serialization consists of 3 parts: an optional context, the set of Feature Structures, and an optional 
    list (by View) of
    the IDs of Feature Structures that were added to the indexes.  The serializer can be configured to omit
    the optional sections for simple cases where that information isn't needed.</para>
    
    <para>The context section has entries for each used type.  The entries are of 3 kinds, 
    each of which can be omitted.  These are the name extension information 
    that maps short type names to their fully qualified names, 
    the specification of which features of a type are references to other Feature Structures, and the supertypes 
    for each Type.  The supertype list for a type is truncated, as soon as it references a type whose supertypes have already been
    given (to reduce serialization space).</para>
    
    <para>Feature Structures themselves are represented as a JSON object consisting of field - value pairs, where the 
    fields correspond to UIMA Features, and the values are primitives, or references to other FSs, 
    and, for UIMA Lists and Array features which are marked with multipleReferencesAllowed=false, 
    a JSON array structure holding the values of the Array or List.</para>
    
    <para>Primitive boolean values are represented by JSON true and false literals. References to other Feature
    Structures are represented as JSON numbers, the value of which is interpreted as the @id of the referred-to
    FS.  These @ids are treated in the same manner as the xmi:ids of XMI Serialization.</para>
    
    <para>Besides the feature values defined for a Feature Structure, there are 2 additional special features
    serialized:  @id and @type.  The @id is the id of the FS; the @type is the type name.  Type names are normally
    represented as their last segment (without the package prefix), unless there is a collision among the things being
    serialized, in which case, they are serialized as name-space-name:type-name, where this combination is defined in the
    @context with an expansion to the fully qualified UIMA type name.</para>
    
    <para>Both of these special features can be omitted for simplicity (via a configuration), if they're not needed.</para>
    
    <para>Following the conventions established in XMI serialization, features of the following types having null values
    are omitted</para>
    <itemizedlist>
      <listitem>
        <para>Feature Structure References</para>
      </listitem>
      <listitem>
        <para>Strings (null, not "" (empty))</para>
      </listitem>
            <listitem>
        <para>Arrays and Lists</para>
      </listitem>
    </itemizedlist>
    
    <para>Note that inside arrays or lists of Feature Structure references, a null reference is coded as the number 0.</para>
    
    <para>Configuring the serializer with <code>setOmitDefaultValues(true)</code> (which is also the default) causes
    additional primitive features (byte/short/int/long/float/double) to be omitted, when their values are 0 or 0.0</para>
    
    <para>Feature Structures can be serialized as indexed maps, with the key being either the @id or the @type (but not both).
    When serialized in this manner, the key can be used in many languages that read this JSON as a key to access the
    associated Feature Structure representation.  If indexed over @id, there's just one unique FS per @id.  
    If indexed over @type, there are potentially many FSs per Type; these are represented as a JSON array of 
    FSs.  The items in the array are sorted by View, and then in the same order that a UIMA Annotation Index would sort things (for 
    types which are subtypes of uima.tcas.Annotation).  This form allows for simple iteration over a single type (not including 
    its subtypes).</para>
    
    <para>The various formats look like these:</para>
    
    <programlisting>   
   INDEX_ID:   

 { "123" : { "@id" : 123, "@type" : "type-name", feat : value, ... }    
   "456" : { "@id" : 456, "@type" : "foo", feat : value ... },
   ...
 }
 
 
  </programlisting>
    
    
    <para>The second format is organized by types.  It's a map, whose key is the type, and the value is a sorted
    array of instances of that type.  The sort is fixed, and first groups things together by View, 
    and then, for subtypes of uima.tcas.Annotation, it sorts by the begin feature (ascending) and then by 
    the end feature (descending).  This form allows for simple iteration over a single type (not including 
    its subtypes).  An additional system-supplied feature, "@id", supplies the ID of this feature
    structure (so it can be referenced by other features of other FSs).</para>

    <para>It looks like this:</para>
    
        <programlisting>
BY_TYPE_EMBED_ID: 

{ "type-name" : [ { "@id" : 123, feat : value ... },    
                  { "@id" : 456, feat : value ... }
                      ...
                ], 
   ...
}</programlisting>
    
        
    <para>Similar to XMI serialization, Arrays and Lists of objects which are the values of a feature,
    are embedded using the JSON array notation, either
    as a feature value, or as a separate object (depending on the setting of the multiple-references-allowed flag in 
    the feature description).  Like XMI serialization, there is no support for arbitrarily linked complex list structures
    created using the built-in list types;
    if the list structure has any back references, the serialization truncates at the point the back reference is detected.
    If an application requires complex linked structures, they can be built using custom-defined
    list types; these will be serialized faithfully.</para>
    
    <para>Type names in the serialization are represented by their short-forms.  The short-form is just the last
    segment (following the last period (.) in the type name), unless there are 2 (or more) different types with the same
    last segment name.  In that case, a name-space prefix is assigned, and the name is written "prefix:last-segment".
    </para>
    
    <para>The name-expansion part of the context gives a mapping from the short-form (either type or prefix:type) 
    to the fully qualified type name.</para>
    
    <para>JSON serialization also supports several additional features, including:</para>
    <itemizedlist>
      <listitem>
        <para>Delta CAS: only serializes changes since the mark was set</para>
      </listitem>
      <listitem>
        <para>Type and feature filtering: only types and features that exist in a specified type system description 
        are serialized.</para>
      </listitem>
      <listitem>
        <para>An ErrorHandler; this will be called in various error situations.</para>
      </listitem>
      <listitem>
        <para>A switch to control omitting of features that have default values (default is to omit these).</para>
      </listitem>
      <listitem>
        <para>a pretty printing flag (default is not to do pretty-printing)</para>
      </listitem>
    </itemizedlist>
        
    <para>Here's a summary of the sections of the CAS JSON serialization.</para>
    <itemizedlist>
      <listitem>
        <para>(optional) A @context section, modeled after JSON-LD.  This has entries for each type that is serialized:</para>
        <itemizedlist>
          <listitem>
            <para>(optional) name expansion.  This provides the full name for UIMA types that correspond to the shorter type names
            used in the body of the serialization.</para>
          </listitem>
          <listitem>
            <para>(optional) feature context: This identifies which features are to be interpreted as references to other 
            feature structure instances, and/or which features are encoded as binary using base64 encoding 
            (per JSON/Jackson standard convention).</para>
          </listitem>
          <listitem>
            <para>(optional) supertypes: this provides information that can be used by the receiver to contruct the inheritance
            tree used by the serialized types.  It can enable iterating over all instances of some type, including 
            all of its subtypes.</para>
          </listitem>
        </itemizedlist>
      </listitem>
      <listitem>
        <para>@cas_feature_structures: For each view in the CAS, the list of feature structures that were added to the index, or, for deltaCas
        serialization (where only the changes are being serialized) which feature structures were indexed or 
        removed from the index.  The formats can include @id and @type extra features, and can optionally
        be serialized as JSON maps for either one of the @id or @type features.</para>
        
        
        <itemizedlist>
          <listitem>
            <para>INDEX_ID: this is a map, the key is the ID</para>
          </listitem>
          <listitem>
            <para>INDEX_TYPE: this is a map, the key is the short-typename</para>
          </listitem>
        </itemizedlist>
      </listitem>
      <listitem>
        <para>(optional) an @cas_views section.  This contains for each view, an array of IDs that were added to the index.  
        These arrays are stored in a map, with the key being the @id for the Sofa FS associated with the view, or
        "0" for the edge case where no Sofa has (yet) been created for a view. For
        delta-cas serialization (where only changes are being serialized), this array is replaced with a map 
        of 3 keys:  "added-members", "deleted-members", and "reindexed-members", the values of which are arrays of IDs.</para>
      </listitem>
    </itemizedlist>
    
    <para>XMI deserialization can be specified with a "lenient" flag, which allows the incoming data to 
    include types and features which are not present in the type system being deserialized into. These 
    data are called "out-of-type-system" data (oots).  The XMI serialization merges back the oots data.
    JSON serialization doesn't support this, mainly because there's no type information available for the 
    oots data, and the JSON @context information for these types can't be generated.</para>
  </section>

  
  <section id="ugr.ref.json.usage">
    <title>Using JSON CAS serialization</title>
    
    <para>The support is built on top the Jackson JSON serialization
    package.  We follow the conventions of Jackson for configuring.</para>
    
    <para>The serialization API is in JsonCasSerializer class.</para>
    
    <para>Although there are some static short-cut methods for common use cases, the basic operations needed
    to serailialize a CAS as JSON are:</para>
    
    <itemizedlist>
      <listitem>
        <para>Make an instance of the JsonCasSerializer class.  This will serve to collect configuration information.</para>
      </listitem>
      <listitem>
        <para>Do any additional configuration needed.  See the Javadocs for details.  The following objects can be configured:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>The JsonCasSerializer object: you can specify the kind of JSON formatting, what to serialize,
            whether or not delta serialization is wanted, prettyprinting, and more.</para>
          </listitem>
          <listitem>
            <para>The underlying JsonFactory from Jackson.  Normally, you won't need to configure this.</para>
          </listitem>
          <listitem>
            <para>The underlying JsonGenerator from Jackson. Normally, you won't need to configure this.</para>
          </listitem>
        </itemizedlist>
      </listitem>
      <listitem>
        <para>Once all the configuration is done, the serialize(...) call is done in this class, 
        which will create a one-time-use
        inner class where the actual serialization is done.  The serialize(...) method is thread-safe, in that the same 
        JsonCasSerializer instance (after it has been configured) can kick off multiple serializations 
        on different threads at the same time.</para>
        <para>The serialize call follows the Jackson conventions, taking one of 3 specifications of where to serialize to:
        a Writer, an OutputStream, or a File.</para>
      </listitem>
    </itemizedlist>
    
    <para>The JsonCasSerializer class also has some static convenience methods for JSON serialization, for the
    most common configuration cases; please see the Javadocs for details. These are named jasonSerialize, to 
    distinguish them from the non-static serialize methods.</para>

  </section>

  <section id="ugr.ref.json.configuration">
    <title>JSON CAS Serialization - Common Configuration</title>
    
    <para>See the Javadocs for the class XmiCasSerialization for a description of the available configurations.</para>
        
    <para>The configuration methods generally return the instance, so they can be chained together.
    For example, if xcs is an instance of the XmiCasSerializer, you can write
    <code>xcs.setPrettyPrint(true).setOmitDefaultvalues(true);</code></para>
        
  </section>  

  </section>
  
  <section>
    <title>TypeSystem Serialization</title>
    
    <para>TypeSystems can be serialized by the toJSON methods defined in JSONizable interface, a super interface of the
    TypeSystemDescription interface.  The toJSON methods take a Writer, File or OutputStream parameter, and 
    an optional prettyprint flag (default is no prettyprinting).</para>
    
    <para>The resulting JSON serialization is just a straight-forward serialization of the typeDescription object,
    having the same fields as the XML serialization of it.</para>
    
    <para>Here's what a small TypeSystem description looks like, serialized:</para>
    
    <programlisting>
{"typeSystemDescription" : 
  {"name" : "casTestCaseTypesystem",  
   "description" : "Type system description for CAS test cases.",  
   "version" : "1.0",  
   "vendor" : "Apache Software Foundation",  
   "types" : [
     {"typeDescription" : 
       {"name" : "Token",  
        "description" : "",  
         "supertypeName" : "uima.tcas.Annotation",  
         "features" : [
           {"featureDescription" : 
             {"name" : "type",  
              "description" : "",  
              "rangeTypeName" : 
              "TokenType" } }, 
           {"featureDescription" : 
             {"name" : "tokenFloatFeat",  
              "description" : "",  
              "rangeTypeName" : "uima.cas.Float" } } ] } }, 
     {"typeDescription" : 
       {"name" : "TokenType",  
        "description" : "",  
        "supertypeName" : "uima.cas.TOP" } } ] } }
    </programlisting>
  </section>
  <!--   
  <section id="ugr.ref.json.use-cases">
    <title>Use Case cookbook</title>
    
    <para>
    Here are some use cases, together with a suggested approach and example of how to use the APIs.
    </para>
    
    <para>
      <emphasis role="strong">Save a CAS to an output stream, using form 4 (no type system filtering):</emphasis>
    </para>
          <programlisting>// set up an output stream.  In this example, an internal byte array.
ByteArrayOutputStream baos = new ByteArrayOutputStream(OUT_BFR_INIT_SZ);
Serialization.serializeWithCompression(casSrc, baos);
</programlisting>
 
      <para><emphasis role="strong">Deserialize from a stream into an existing CAS:</emphasis></para>
      <programlisting>// assume the stream is a byte array input stream
// For example, one could be created 
//   from the above ByteArrayOutputStream as follows:
ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
// Deserialize into a cas having the identical type system
Serialization.deserializeCAS(cas, bais);
</programlisting>

<para>Note that the <code>deserializeCAS(cas, inputStream)</code> method is a general way to
deserialize into a CAS from an inputStream for all forms of binary serialized data
(with exceptions as noted above).
The method reads a common header, and based on what it finds, selects the appropriate
deserialization routine.</para>

<note><para>The <code>deserialization</code> method with just 2 arguments method doesn't support type filtering, or
delta cas deserializating for form 6. To do those, see example below. 
</para>
</note>

<para><emphasis role="strong">Serialize to an output stream, filtering out some types and/or features:</emphasis>
</para>
<para>
To do this, an additional input specifying the Type System of the target must
be supplied; this Type System should be a subset of the source CAS's.
The <code>out</code> parameter may be an OutputStream, a DataOutputStream, or a File.
</para>

<programlisting>// set up an output stream.  In this example, an internal byte array.
ByteArrayOutputStream baos = new ByteArrayOutputStream(OUT_BFR_INIT_SZ);
Serialization.serializeWithCompression(cas, out, tgtTypeSystem);
</programlisting>

<para><emphasis role="strong">Deserialize with type filtering:</emphasis></para>
<para>The reuseInfo should be null unless 
deserializing a delta CAS, in which case, it must be the reuse info captured when 
the original CAS was serialized out. 
If the target type system is identical to the one in the CAS, you may pass null for it.
If a delta cas is not being received, you must pass null for the reuseInfo.
</para>
<programlisting>ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
Serialization.deserializeCAS(cas, bais, tgtTypeSystem, reuseInfo);
</programlisting> 
</section>
  -->

</chapter>